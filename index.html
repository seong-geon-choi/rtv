<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 TV</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>실시간 TV 시청</h1>
            <p>무료로 실시간 TV를 시청하세요</p>
        </header>
        
        <main class="channels">
            <div class="channel-grid" id="mainChannels">
                <a href="https://onair.imbc.com/" target="_blank" class="channel-card" draggable="true" data-channel="mbc">
                    <div class="channel-logo mbc">
                        <img src="https://www.imbc.com/favicon.ico" alt="MBC" onerror="this.style.display='none'">
                        MBC
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>

                <a href="https://www.sbs.co.kr/live" target="_blank" class="channel-card" draggable="true" data-channel="sbs">
                    <div class="channel-logo sbs">
                        <img src="https://www.sbs.co.kr/favicon.ico" alt="SBS" onerror="this.style.display='none'">
                        SBS
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>

                <a href="https://onair.kbs.co.kr/index.html?sname=onair&stype=live&ch_code=12" target="_blank" class="channel-card" draggable="true" data-channel="kbs2">
                    <div class="channel-logo kbs2">
                        <img src="https://www.kbs.co.kr/favicon.ico" alt="KBS2" onerror="this.style.display='none'">
                        KBS2
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>

                <a href="https://www.ebs.co.kr/onair" target="_blank" class="channel-card" draggable="true" data-channel="ebs">
                    <div class="channel-logo ebs">
                        <img src="https://www.ebs.co.kr/favicon.ico" alt="EBS" onerror="this.style.display='none'">
                        EBS
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>

                <a href="https://onair.kbs.co.kr/index.html?sname=onair&stype=live&ch_code=11" target="_blank" class="channel-card" draggable="true" data-channel="kbs1">
                    <div class="channel-logo kbs1">
                        <img src="https://www.kbs.co.kr/favicon.ico" alt="KBS1" onerror="this.style.display='none'">
                        KBS1
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>
            </div>

            <div class="channel-grid" id="otherChannels">
                <a href="https://01.ondotv.com/" target="_blank" class="channel-card" draggable="true" data-channel="ondotv">
                    <div class="channel-logo">
                        <img src="https://01.ondotv.com/favicon.ico" alt="온도티비" onerror="this.style.display='none'">
                        온도티비
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>

                <a href="https://tvchak.org/" target="_blank" class="channel-card" draggable="true" data-channel="tvchak">
                    <div class="channel-logo">
                        <img src="https://tvchak.orgfavicon.ico" alt="티비착" onerror="this.style.display='none'">
                        티비착
                    </div>
                    <div class="channel-btn">시청하기</div>
                </a>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const mainChannels = document.getElementById('mainChannels');
            const otherChannels = document.getElementById('otherChannels');
            let draggedCard = null;
            let moveMode = false;
            let moveTimer = null;
            let placeholder = document.createElement('div');
            placeholder.className = 'channel-placeholder';

            // 저장된 순서 불러오기
            function loadChannelOrder() {
                const mainOrder = localStorage.getItem('mainChannelsOrder');
                const otherOrder = localStorage.getItem('otherChannelsOrder');

                if (mainOrder) {
                    const mainOrderArray = JSON.parse(mainOrder);
                    reorderChannels(mainChannels, mainOrderArray);
                }

                if (otherOrder) {
                    const otherOrderArray = JSON.parse(otherOrder);
                    reorderChannels(otherChannels, otherOrderArray);
                }
            }

            // 채널 순서 저장하기
            function saveChannelOrder() {
                const mainOrder = Array.from(mainChannels.children).filter(card => !card.classList.contains('channel-placeholder')).map(card => card.dataset.channel);
                const otherOrder = Array.from(otherChannels.children).filter(card => !card.classList.contains('channel-placeholder')).map(card => card.dataset.channel);

                localStorage.setItem('mainChannelsOrder', JSON.stringify(mainOrder));
                localStorage.setItem('otherChannelsOrder', JSON.stringify(otherOrder));
            }

            // 채널 순서 재정렬
            function reorderChannels(container, orderArray) {
                const currentCards = Array.from(container.children).filter(card => !card.classList.contains('channel-placeholder'));
                const orderedCards = [];

                orderArray.forEach(channelId => {
                    const card = currentCards.find(card => card.dataset.channel === channelId);
                    if (card) {
                        orderedCards.push(card);
                    }
                });

                // 순서가 저장되지 않은 카드들도 추가
                currentCards.forEach(card => {
                    if (!orderedCards.includes(card)) {
                        orderedCards.push(card);
                    }
                });

                container.innerHTML = '';
                orderedCards.forEach(card => container.appendChild(card));
            }

            // 드래그 앤 드롭/이동 모드 이벤트 처리
            document.querySelectorAll('.channel-card').forEach(card => {
                card.draggable = false;
                card.classList.remove('move-mode');

                // 1초 이상 클릭 시 이동 모드 진입
                card.addEventListener('mousedown', function(e) {
                    if (moveMode) return;
                    moveTimer = setTimeout(() => {
                        moveMode = true;
                        card.classList.add('move-mode');
                        card.draggable = true;
                    }, 1000);
                });
                card.addEventListener('mouseup', function(e) {
                    clearTimeout(moveTimer);
                });
                card.addEventListener('mouseleave', function(e) {
                    clearTimeout(moveTimer);
                });
                // 이동 모드 해제(드래그 끝나면)
                card.addEventListener('dragend', function() {
                    card.classList.remove('move-mode');
                    card.draggable = false;
                    moveMode = false;
                    this.classList.remove('dragging');
                    if (placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
                    saveChannelOrder();
                });
                // 드래그 시작
                card.addEventListener('dragstart', function(e) {
                    if (!moveMode) {
                        e.preventDefault();
                        return;
                    }
                    draggedCard = this;
                    this.classList.add('dragging');
                    // 드래그 시작 시 플레이스홀더 추가
                    setTimeout(() => {
                        this.style.display = 'none';
                        this.parentNode.insertBefore(placeholder, this.nextSibling);
                    }, 0);
                });
                // 클릭 이벤트 처리
                card.addEventListener('click', function(e) {
                    if (this.classList.contains('dragging')) {
                        e.preventDefault();
                    }
                });
                // 모바일 터치(1초 이상)
                card.addEventListener('touchstart', function(e) {
                    if (moveMode) return;
                    moveTimer = setTimeout(() => {
                        moveMode = true;
                        card.classList.add('move-mode');
                        card.draggable = true;
                    }, 1000);
                });
                card.addEventListener('touchend', function(e) {
                    clearTimeout(moveTimer);
                    if (moveMode) {
                        card.classList.remove('move-mode');
                        card.draggable = false;
                        moveMode = false;
                    }
                });
                card.addEventListener('touchmove', function(e) {
                    clearTimeout(moveTimer);
                });
            });

            [mainChannels, otherChannels].forEach(container => {
                container.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    const afterElement = getGridDragAfterElement(container, e.clientX, e.clientY);
                    if (afterElement === placeholder) return;
                    if (placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
                    if (afterElement == null) {
                        container.appendChild(placeholder);
                    } else {
                        container.insertBefore(placeholder, afterElement);
                    }
                });
                container.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (placeholder.parentNode) {
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                        draggedCard.style.display = '';
                        draggedCard.classList.remove('dragging');
                        draggedCard.classList.remove('move-mode');
                        draggedCard.draggable = false;
                        moveMode = false;
                        saveChannelOrder();
                    }
                });
            });

            function getGridDragAfterElement(container, x, y) {
                const elements = [...container.querySelectorAll('.channel-card:not(.dragging), .channel-placeholder')];
                if (elements.length === 0) return null;
                let closest = null;
                let closestDist = Infinity;
                let rowLast = null;
                let rowLastRect = null;
                // 각 카드의 rowTop을 기준으로 같은 행의 마지막 카드 찾기
                elements.forEach(el => {
                    if (el.classList.contains('channel-placeholder')) return;
                    const rect = el.getBoundingClientRect();
                    const rowTop = Math.round(rect.top);
                    // 마우스가 이 카드의 행에 있는지 확인
                    if (y >= rect.top && y <= rect.bottom) {
                        if (!rowLast || rect.left > rowLastRect.left) {
                            rowLast = el;
                            rowLastRect = rect;
                        }
                    }
                    // 기존 가장 가까운 카드 찾기(기본 동작)
                    const dx = x - (rect.left + rect.width / 2);
                    const dy = y - (rect.top + rect.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = el;
                    }
                });
                // 마우스가 행의 마지막 카드 오른쪽(빈 공간)에 있으면 그 행의 마지막 뒤에 placeholder
                if (rowLast && x > rowLastRect.right) {
                    return rowLast.nextSibling;
                }
                // 마우스가 그리드의 오른쪽/아래쪽 끝에 있으면 null 반환 → 맨 끝에 추가
                const gridRect = container.getBoundingClientRect();
                if (x > gridRect.right - 10 || y > gridRect.bottom - 10) return null;
                // 카드가 1개 이하이거나, 마우스가 마지막 카드의 오른쪽 아래에 있으면 null 반환
                if (elements.length > 0) {
                    const last = elements[elements.length - 1];
                    const lastRect = last.getBoundingClientRect();
                    if (x > lastRect.right - 10 && y > lastRect.bottom - 10) return null;
                }
                return closest;
            }

            // 초기 순서 불러오기
            loadChannelOrder();
        });
    </script>
</body>
</html>